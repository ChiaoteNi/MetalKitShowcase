//
//  WatermarkMetalRenderer.swift
//  VideoCompositionDemo
//
//  Created by Chiaote Ni on 2022/11/28.
//

import Foundation
import MetalKit

// Metalâ€™s textures originate in the top-left corner.
// The coordinates within the texture are normalized and always within the range of 0->1
// More information you can see the in chapter 1.6 - Metal Coordinate Systems in the following document:
// https://developer.apple.com/metal/Metal-Shading-Language-Specification.pdf
// Especially the Figure 1 and Figure 3

fileprivate class PixelBuffers {
    let outputBuffer: CVPixelBuffer
    let sourceBuffers: [CVPixelBuffer]

    init(outputBuffer: CVPixelBuffer, sourceBuffers: [CVPixelBuffer]) {
        self.outputBuffer = outputBuffer
        self.sourceBuffers = sourceBuffers
    }
}

final class WatermarkMetalRenderer {

    /// A `MTLDevice` object instance representing a GPU that can execute commands.
    private let device: MTLDevice

    /// A `MTLCommandQueue` object used to queue the command buffers for the Metal device to execute.
    private let commandQueue: MTLCommandQueue

    /// The default library contains all of the shader functions that were compiled into our app bundle.
    private let library: MTLLibrary

    private let textureLoader: MTKTextureLoader

    /// Object used to retain the buffers for rendering of textures associated with video frames.
    private var currentPixelBuffers: PixelBuffers?

    // We need to retain the value ourselves, but it's still not required to declare it as a property of the renderer.
    // I've made it a property here just for demonstration purposes to simplify the explanation.
    var opacity: Float = 0.1

    init?() {
        guard
            // Ask for the default Metal device; this represents our GPU.
            let device = MTLCreateSystemDefaultDevice(),
            let commandQueue = device.makeCommandQueue(),
            // The compiler will compile all shader files into 1 library as the default library, but you can use other library as well.
            let library = device.makeDefaultLibrary()
        else {
            return nil
        }
        self.device = device
        // Create the command queue to submit work to the GPU.
        self.commandQueue = commandQueue
        self.library = library
        self.textureLoader = MTKTextureLoader(device: device)
    }

    func renderPixelBuffer(
        _ outputBuffer: CVPixelBuffer,
        sources pixelBuffers: [CVPixelBuffer],
        watermark: UIImage?
    ) {
        let outputTexture = makeTexture(with: outputBuffer)
        let textures = pixelBuffers.compactMap { makeTexture(with: $0) }

        guard let outputTexture = outputTexture, !textures.isEmpty else {
            return
        }
        // Hold the texture until finish rendering.
        // This is because metal won't increase the retain count for the textures while rendering, so we need to do this by ourselves
        currentPixelBuffers = PixelBuffers(
            outputBuffer: outputBuffer,
            sourceBuffers: pixelBuffers
        )

        // set up the collection of attachments used as the rendering destination for pixels generated by a rendering pass.
        // in this case, we only need one rendering destination at the same time
        let renderPassDescriptor = MTLRenderPassDescriptor()
        renderPassDescriptor.colorAttachments[0].texture = outputTexture
        renderPassDescriptor.colorAttachments[0].loadAction = .load // demo this with only 3 video

        guard
            let commandBuffer = commandQueue.makeCommandBuffer(),
            let renderEncoder = commandBuffer.makeRenderCommandEncoder(descriptor: renderPassDescriptor),
            let vertexFunction = library.makeFunction(name: "watermark_vertex_point_func"),
            let fragmentFunction = library.makeFunction(name: "watermark_fragment_point_func")
        else {
            return
        }

        // Set up the rendering configuration state to use during a rendering pass
        let pipelineDescriptor = MTLRenderPipelineDescriptor()
        pipelineDescriptor.vertexFunction = vertexFunction
        pipelineDescriptor.fragmentFunction = fragmentFunction
        pipelineDescriptor.colorAttachments[0].pixelFormat = .bgra8Unorm

        // Considering our focus on blending a watermark onto our video in this demonstration,
        // we'll simplify the steps by skipping rendering if the watermark texture creation fails.
        guard let watermark, let watermarkTexture = makeTexture(with: watermark) else {
            assertionFailure("Exception: Watermark texture create failed")
            return
        }

        do {
            let pipelineState = try device.makeRenderPipelineState(descriptor: pipelineDescriptor)
            // position video with vertexes
            textures
                .enumerated()
                .forEach {
                    offset,
                    texture in
                    // defined how to render the target texture
                    
                    let baseTextureInfo = FragmentTextureInfo(
                        texture: texture,
                        textureCoordinates: makeTextureCoordinate()
                    )
                    let watermarkTextureInfo = FragmentTextureInfo(
                        texture: watermarkTexture,
                        textureCoordinates: makeWatermarkTextureCoordinate()
                    )
                    renderTexture(
                        with: renderEncoder,
                        vertexes: makeVertexes(),
                        base: baseTextureInfo,
                        watermark: watermarkTextureInfo,
                        pipelineState: pipelineState
                    )
                }
        } catch {
            debugPrint("ðŸ’¥", error)
        }
        renderEncoder.endEncoding()
        commandBuffer.commit()
    }
}

extension WatermarkMetalRenderer {

    private struct FragmentTextureInfo {
        let texture: MTLTexture
        let textureCoordinates: [SIMD2<Float>]
    }

    private func renderTexture(
        with renderEncoder: MTLRenderCommandEncoder,
        vertexes: [SIMD4<Float>],
        base: FragmentTextureInfo,
        watermark: FragmentTextureInfo,
        pipelineState: MTLRenderPipelineState
    ) {
        // Set the current render pipeline state object.
        renderEncoder.setRenderPipelineState(pipelineState)

        // This is the same as create buffer with `setVertexBuffer`, then call setVertexBuffer(_:offset:index:)
        // The method `setVertexBytes` avoids the overhead of creating a buffer to store your data; instead, Metal manages the data.
        // Use this method for single-use data smaller than 4 KB
        renderEncoder.setVertexBytes(
            vertexes,
            length: vertexes.count * MemoryLayout<SIMD4<Float>>.size,
            index: 0
        )

        renderEncoder.setFragmentBytes(&opacity, length: MemoryLayout<Float>.size, index: 0)

        let baseCoordinates = base.textureCoordinates
        renderEncoder.setVertexBytes(
            baseCoordinates,
            length: baseCoordinates.count * MemoryLayout<SIMD2<Float>>.size,
            index: 1
        )
        renderEncoder.setFragmentTexture(base.texture, index: 0)

        let watermarkCoordinates = watermark.textureCoordinates
        renderEncoder.setVertexBytes(
            watermarkCoordinates,
            length: watermarkCoordinates.count * MemoryLayout<SIMD2<Float>>.size,
            index: 2
        )
        renderEncoder.setFragmentTexture(watermark.texture, index: 1)

        // ðŸ–Œ
        // Tell the render context we want to draw our primitives (triangle strip).
        renderEncoder.drawPrimitives(
            type: .triangleStrip,
            vertexStart: 0,
            vertexCount: vertexes.count, // The vertexes are with the four-dimensional homogenous vector
            instanceCount: 1
        )
    }

    // MARK: - Vertexes

    private func makeVertexes() -> [SIMD4<Float>] {
        let coordinates: [SIMD2<Float>] = {
//            // Case 1: type = triangle
//            return [
//                SIMD2<Float>(1, 1),
//                SIMD2<Float>(-1, 1),
//                SIMD2<Float>(-1, -1),
//                SIMD2<Float>(1, 1),
//                SIMD2<Float>(-1, -1),
//                SIMD2<Float>(1, -1)
//            ]
             // Case 2: type = triangleStrip
             // NOTE: tweak the points to show the behavior for triangleStrip
             return [
                 SIMD2<Float>(-1, 1),
                 SIMD2<Float>(1, 1),
                 SIMD2<Float>(-1, -1),
                 SIMD2<Float>(1, -1)
             ]
        }()
        return coordinates.map { SIMD4<Float>($0.x, $0.y, 0, 1) }
    }

    private func makeTextureCoordinate() -> [SIMD2<Float>] {
//        // Case 1: type = triangle
//        return [
//            SIMD2<Float>(1, 0),
//            SIMD2<Float>(0, 0),
//            SIMD2<Float>(0, 1),
//            SIMD2<Float>(1, 0),
//            SIMD2<Float>(0, 1),
//            SIMD2<Float>(1, 1)
//        ]
         // Case 2: type = triangleStrip
         return [
             SIMD2<Float>(0, 0),
             SIMD2<Float>(1, 0),
             SIMD2<Float>(0, 1),
             SIMD2<Float>(1, 1)
         ]
    }

    private func makeWatermarkTextureCoordinate() -> [SIMD2<Float>] {
//        // Case 1: type = triangle
//        return [
//            SIMD2<Float>(1, 0),
//            SIMD2<Float>(0, 0),
//            SIMD2<Float>(0, 1),
//            SIMD2<Float>(1, 0),
//            SIMD2<Float>(0, 1),
//            SIMD2<Float>(1, 1)
//        ]
//         // Case 2: type = triangleStrip
//         return [
//             SIMD2<Float>(0, 0),
//             SIMD2<Float>(1, 0),
//             SIMD2<Float>(0, 1),
//             SIMD2<Float>(1, 1)
//         ]
//        // Case 3: type = triangleStrip, watermark positioned at the bottom-right side
//        return [
//           SIMD2<Float>(-1, -1),
//           SIMD2<Float>(1, -1),
//           SIMD2<Float>(-1, 1),
//            SIMD2<Float>(1, 1)
//        ]
        // Case 4: type = triangleStrip, watermark positioned at the bottom-right side
        return [
            SIMD2<Float>(0, 0),
           SIMD2<Float>(2, 0),
           SIMD2<Float>(0, 2),
            SIMD2<Float>(2, 2)
        ]
    }

    // MARK: - Texture

    private func makeTexture(with image: UIImage) -> MTLTexture? {
        guard
            let cgImage = image.cgImage,
            let texture = try? textureLoader.newTexture(cgImage: cgImage, options: nil)
        else {
            return nil
        }
        return texture
    }

    private func makeTexture(with pixelBuffer: CVPixelBuffer) -> MTLTexture? {
        let textureWidth = CVPixelBufferGetWidth(pixelBuffer)
        let textureHeight = CVPixelBufferGetHeight(pixelBuffer)

        let descriptor = MTLTextureDescriptor.texture2DDescriptor(
            pixelFormat: .bgra8Unorm,
            width: textureWidth,
            height: textureHeight,
            mipmapped: false
        )
        // Set up this because Metal can optimize operations for a given texture, based on its intended use.
        descriptor.usage = [
            .renderTarget,  // Declare this if we need set up texture to the colorAttachment[0]
            .shaderRead     // Declare this if we need to use texture in the shader function.
        ]

        guard
            // IOSurface is a high-level abstraction around shared memory:
            // â€¢ Very efficient cross-process and cross-API data sharing
            // â€¢ Integrated directly into GPU software stack
            // â€¢ Hides details about moving data between CPU and GPUs
            let ioSurface = CVPixelBufferGetIOSurface(pixelBuffer)?.takeUnretainedValue(), // In our demo, we've already retain all the pixelBuffer by ourselves
            let texture = device.makeTexture(
                descriptor: descriptor,
                iosurface: ioSurface,
                plane: 0
            )
        else {
            return nil
        }
        return texture
    }
}

